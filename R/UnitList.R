#######################################################################
#
# Package Name: SeqArray
#
# Description: A list of units of selected variants
#


#######################################################################
# Get a list of units of selected variants via sliding windows based on basepairs
#
seqUnitSlidingWindows <- function(gdsfile, win.size=5000L, win.shift=2500L, win.start=0L,
    verbose=TRUE)
{
    stopifnot(inherits(gdsfile, "SeqVarGDSClass"))
    stopifnot(is.numeric(win.size), is.finite(win.size), length(win.size)==1L,
        win.size>0L)
    stopifnot(is.numeric(win.shift), is.finite(win.shift), length(win.shift)==1L,
        win.shift>0L)
    stopifnot(is.numeric(win.start), is.finite(win.start), length(win.start)==1L)
    stopifnot(is.logical(verbose), length(verbose)==1L)

    # save state
    seqSetFilter(gdsfile, action="push", verbose=FALSE)
    on.exit({ seqSetFilter(gdsfile, action="pop", verbose=FALSE) })

    # chromosome list
    chrlst <- unique(seqGetData(gdsfile, "chromosome"))
    if (length(chrlst) <= 0L) stop("No selected variant!")
    ans <- NULL
    for (chr in chrlst)
    {
        if (verbose)
            cat("Chromosome ", chr, ", ", sep="")
        seqSetFilterChrom(gdsfile, include=chr, verbose=FALSE)
        idx <- which(seqGetFilter(gdsfile)$variant.sel)
        pos <- seqGetData(gdsfile, "position")
        if (!is.unsorted(pos) || pos[1L]>pos[length(pos)])
        {
            i <- order(pos)
            pos <- pos[i]; idx <- idx[i]
        }
        # generated by sliding windows
        rv <- .Call(SEQ_Unit_SlidingWindows, pos, idx, win.size, win.shift, win.start,
            integer(length(pos)))
        names(rv) <- rep(paste0("chr", chr), length(rv))
        ans <- c(ans, rv)
        if (verbose)
            cat("# of units: ", length(rv), "\n", sep="")
        # reset
        seqSetFilter(gdsfile, action="pop", verbose=FALSE)
        seqSetFilter(gdsfile, action="push", verbose=FALSE)
    }
    if (verbose)
        cat("# of units in total: ", length(ans), "\n", sep="")

    # output
    class(ans) <- "SeqUnitListClass"
    ans
}


#######################################################################
# Get a list of units of selected variants via sliding windows based on basepairs
#
seqUnitApply <- function(gdsfile, units, var.name, FUN, as.is=c("none", "list", "unlist"),
    parallel=FALSE, .useraw=FALSE, .progress=FALSE, ...)
{
    # check
    stopifnot(inherits(gdsfile, "SeqVarGDSClass"))
    stopifnot(inherits(units, "SeqUnitListClass"))
    stopifnot(is.character(var.name), length(var.name)>0L)
    FUN <- match.fun(FUN)
    stopifnot(length(units) > 0L)
    as.is <- match.arg(as.is)
    stopifnot(is.logical(.useraw), length(.useraw)==1L)
    stopifnot(is.logical(.progress), length(.progress)==1L)

    # initialize internally
    .Call(SEQ_IntAssign, process_index, 1L)
    .Call(SEQ_IntAssign, process_count, 1L)

    # get the number of workers
    njobs <- .NumParallel(parallel)
    if (njobs == 1L)
    {
        # save state
        seqSetFilter(gdsfile, action="push", verbose=FALSE)
        on.exit({ seqSetFilter(gdsfile, action="pop", verbose=FALSE) })
        # progress information
        progress <- if (.progress) .seqProgress(length(units), njobs) else NULL
        # for-loop
        ans <- vector("list", length(units))
        var1L <- length(var.name) == 1L
        for (i in seq_along(units))
        {
            ut <- units[[i]]
            seqSetFilter(gdsfile, variant.sel=ut, verbose=FALSE)
            if (var1L)
            {
                x <- seqGetData(gdsfile, var.name, .useraw=.useraw)
            } else {
                x <- lapply(var.name, function(nm)
                    seqGetData(gdsfile, nm, .useraw=.useraw))
                names(x) <- names(var.name)
            }
            ans[[i]] <- FUN(x, ...)
            .seqProgForward(progress, 1L)
        }
        # finalize
        remove(progress)

    } else {
        # multiple processes
        if (.IsForking(parallel))
        {
            # forking
            .packageEnv$gdsfile <- gdsfile
            .packageEnv$units <- units
            parallel <- parallel::makeForkCluster(njobs)
            on.exit({
                .packageEnv$gdsfile <- .packageEnv$units <- NULL
                stopCluster(parallel)
            })
        } else {
            # distribute the parameters to each node
            clusterCall(parallel, function(gdsfn, units) {
                .packageEnv$gdsfile <- SeqArray::seqOpen(gdsfn, allow.duplicate=TRUE)
                .packageEnv$units <- units
            }, gdsfn=gdsfile$filename, units=units)
            # finalize
            on.exit({
                clusterCall(parallel, function(gdsfn, units) {
                    SeqArray::seqClose(.packageEnv$gdsfile)
                    .packageEnv$units <- NULL
                })
            })
        }
        # progress information
        progress <- if (.progress) .seqProgress(length(units), njobs) else NULL
        # distributed for-loop
        ans <- .DynamicClusterCall(parallel, length(units), .fun=function(i, ...)
            {
                seqSetFilter(.packageEnv$gdsfile, variant.sel=.packageEnv$units[[i]],
                    verbose=FALSE)
                if (length(var.name)==1L)
                {
                    x <- seqGetData(.packageEnv$gdsfile, var.name, .useraw=.useraw)
                } else {
                    x <- lapply(var.name, function(nm)
                        seqGetData(.packageEnv$gdsfile, nm, .useraw=.useraw))
                    names(x) <- names(var.name)
                }
                FUN(x, ...)
            }, .combinefun=as.is,
            .updatefun=function(i) .seqProgForward(progress, 1L), ...)
        # finalize
        remove(progress)
    }

    # output
    if (as.is == "unlist")
        ans <- unlist(ans, recursive=FALSE)
    else if (as.is == "none")
        ans <- invisible()
    ans
}

